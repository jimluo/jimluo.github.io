<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, viewport-fit=cover"
    />

    <style>
      :root {
        --accent-color: #05a081;
        --accent-color-light: #82d0c0;
        --accent-overlay-color: #fff;
        --body-bg: #fff;
        --body-color: #000;
        --heading-color: #000;
        --table-bg-even: #f3f3f3;
        --table-border-bottom: #dddddd;
      }
      
    </style>

    <meta name="theme-color" content="#05a081" />

    
      <link rel="icon" href="https:&#x2F;&#x2F;jimluo.github.io&#x2F;processed_images&#x2F;106e1fb7d8c11fe100.png" />
      <link rel="apple-touch-icon" sizes="48x48" href="https:&#x2F;&#x2F;jimluo.github.io&#x2F;processed_images&#x2F;106e1fb7d8c11fe100.png" />
      <link rel="apple-touch-icon" sizes="72x72" href="https:&#x2F;&#x2F;jimluo.github.io&#x2F;processed_images&#x2F;38c5aeca4d24ddfe00.png" />
      <link rel="apple-touch-icon" sizes="96x96" href="https:&#x2F;&#x2F;jimluo.github.io&#x2F;processed_images&#x2F;74cf6cb0a69d143300.png" />
      <link rel="apple-touch-icon" sizes="144x144" href="https:&#x2F;&#x2F;jimluo.github.io&#x2F;processed_images&#x2F;b7f9a884e270881000.png" />
      <link rel="apple-touch-icon" sizes="192x192" href="https:&#x2F;&#x2F;jimluo.github.io&#x2F;processed_images&#x2F;67ecf87962747c1700.png" />
      <link rel="apple-touch-icon" sizes="256x256" href="https:&#x2F;&#x2F;jimluo.github.io&#x2F;processed_images&#x2F;73ad5705c9d7c81300.png" />
      <link rel="apple-touch-icon" sizes="384x384" href="https:&#x2F;&#x2F;jimluo.github.io&#x2F;processed_images&#x2F;1c22f6dd0a34f84400.png" />
      <link rel="apple-touch-icon" sizes="512x512" href="https:&#x2F;&#x2F;jimluo.github.io&#x2F;processed_images&#x2F;f9196920c2e9808000.png" />
      
    

    

    <meta property="og:type" content="website">

    <meta name="twitter:card" content="summary">

    

    

    
      
        <meta name="description" content="输出是最好的学习方式" />
        <meta name="twitter:description" content="输出是最好的学习方式">
      
    

    
      <meta name="twitter:title" content="IPFS与web2.0的简单比较">
    

    
      <link rel="prerender" href="https:&#x2F;&#x2F;github.com&#x2F;jimluo" />
    

    <link rel="prefetch" href="https:&#x2F;&#x2F;jimluo.github.io&#x2F;processed_images&#x2F;2abb4f8ff69df78500.png" />

    <title>
      
        
          IPFS与web2.0的简单比较
        
      
    </title>

    
    
      <link rel="stylesheet" href="https://jimluo.github.io/main.css">
    
    
  
    <link rel="prerender" href="https:&#x2F;&#x2F;jimluo.github.io&#x2F;audit-upgrade&#x2F;">
  

  

  
    <link rel="prerender"  href="https://jimluo.github.io/tags/linux/">
  

  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "NewsArticle",
      "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://google.com/article"
      },
      "headline": "IPFS与web2.0的简单比较",
      "image": [],
      "datePublished": "2022-06-18T00:00:00+00:00",
      "dateModified": "2022-06-18T00:00:00+00:00",
      "author": {
        "@type": "Person",
        "name": "罗进"
      },
       "publisher": {
        "@type": "Organization",
        "name": "罗进",
        "logo": {
          "@type": "ImageObject",
          "url": "https://jimluo.github.io/icon.png"
        }
        
      }
      
    }
  </script>

  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      "itemListElement": [
        

        
        {
          
          "@type": "ListItem",
          "position": 1,
          "name": "",
          "item": "https://jimluo.github.io/"
        },
        
        {
          "@type": "ListItem",
          "position": 2,
          "name": "IPFS与web2.0的简单比较",
          "item": "https://jimluo.github.io/ipfs/"
        }
      ]
    }
  </script>

  </head>
  <body>
    
      <header>
        <a class="profile-icon" href="/">
          <img src="https:&#x2F;&#x2F;jimluo.github.io&#x2F;processed_images&#x2F;2abb4f8ff69df78500.png" alt="profile picture">
        </a>
        <nav>
          
            <a href="https:&#x2F;&#x2F;github.com&#x2F;jimluo">Github</a>
          
        </nav>
      </header>
    
    <main>
    
  <div class="post-title">
    <h1>IPFS与web2.0的简单比较</h1>
    <small>
      June 18, 2022
      
        - 
        <span class="tags">
          
            <a href="https://jimluo.github.io/tags/linux/">Linux</a>
          
        </span>
      
    </small>
  </div>

  <div>
    <p>对IPFS技术的好奇，源于2点</p>
<ul>
<li>已有经验，原来做视频会议时有p2p的通话，多人会议就是多p2多p(基于WebRTC的SFU)。</li>
<li>web3.0的好奇，通过IPFS检验订正下自己设计一套网络系统的能力</li>
</ul>
<p>历史成因</p>
<ol>
<li>2008年中本聪对英国政府增发货币不满，认为国家不发币也可以规避通货膨胀带来的恶果，就开发了<a href="https://bitcoin.org">比特币</a></li>
<li>2010年<a href="https://vitalik.ca">Vitalik</a>对暴雪擅自削弱魔兽世界里术士的魔法，担心中心化服务的问题，2013年开发了<a href="https://ethereum.org">以太坊</a></li>
<li>2014年以太坊的<a href="https://gavwood.com">Gavin Wood</a>提出web3.0(去中心化、互通增强、所有权)</li>
<li>2014年开始由Juan Benet设计IPFS，后由<a href="https://protocol.ai/">Protocol Labs</a>在开源社区的帮助下发展起来</li>
</ol>
<p>本篇文章思考和写作是基于</p>
<ul>
<li>与web2.0的比较（将中心化的功能拆装到每个peer中）</li>
<li>参考通俗畅达的<a href="https://research.protocol.ai/tutorials/resnetlab-on-tour/">IPFS的教程</a></li>
</ul>
<h2 id="zi-shang-er-xia-de-wang-luo-liu-cheng">自上而下的网络流程</h2>
<pre style="background-color:#f9f9f9;color:#111111;"><code><span>网上有一道高频面试题：浏览器从输入网址到页面展示的过程？</span><span>
</span></code></pre>
<p>网上的讨论结果和详细解答很多，很多人正是基于此题把还给老师的网络原理课又借了回来不准备还了。</p>
<p>我想究其原因，网络原理细节丛生，多课程交叉，多数内容不易于用语言(老师和书)描述，所以很多图解xxx的书收视率一直居高不下，也确实是很适合人脑。</p>
<p>说到IPFS原理，提供了很多文档和宣传，但都没有整合如网络课本的系统，初看时被其宣传放大的优点牵引，细节蔓延。遇到向别人解释时，就变成讲故事讲案例了。</p>
<p>我想顺着自上而下的网络流程和基于中心化网络的比较，能更适合人脑理解吸收。</p>
<p>这道题的答案是</p>
<ul>
<li>URL输入</li>
<li>DNS解析寻址</li>
<li>建立TCP连接</li>
<li>发送HTTPS请求</li>
<li>服务器响应请求</li>
<li>浏览器解析渲染页面</li>
<li>HTTPS请求结束，断开TCP连接</li>
</ul>
<p>重点要解释URL、DNS、HTTP、TLS、TCP和渲染的细节，这些技术的产生的背景和约束，回过头来再系统概括之间的关系，其他非功能因素(效率、成本、安全、兼容)对系统的塑造，应该就能回答的比较完善了。</p>
<p>IPFS去中心化时这道题的答案与中心化时对比差异</p>
<ul>
<li>cid输入</li>
<li>DHT寻址路由</li>
<li>libp2p建立多个p2p连接</li>
<li>发送bitswap请求</li>
<li>peers响应请求</li>
<li>IPLD内容组合</li>
<li>浏览器解析渲染页面</li>
<li>libp2p请求结束，断开连接</li>
</ul>
<p>重点是内容寻址、内容路由、内容交换</p>
<ol>
<li>寻址内容，内容间互转换寻址，通过IPLD。不依赖底层协议</li>
<li>链接内容，将内容之间的链接嵌入到该内容地址，通过Merkle DAG</li>
<li>发现内容：分布式哈希表,Bitswap</li>
</ol>
<p><img src="../images/ipfs/layer.png" alt="layer" /></p>
<h2 id="shu-ru-di-zhi-urlji-yu-wei-zhi-yu-cidji-yu-nei-rong">输入地址 url基于位置与cid基于内容</h2>
<pre style="background-color:#f9f9f9;color:#111111;"><code><span>http url: scheme://host.domain:port/path/filename</span><span>
</span><span>
</span><span>IPFS cidv1: &lt;multibase-prefix&gt;&lt;multicodec-cidv1&gt;&lt;multicodec-content-type&gt;&lt;multihash-content-address&gt;</span><span>
</span></code></pre>
<p>cid（ContentID）
<img src="../images/ipfs/cid.png" alt="cid" /></p>
<pre data-lang="rs" style="background-color:#f9f9f9;color:#111111;" class="language-rs "><code class="language-rs" data-lang="rs"><span style="color:#8e908c;">// create cid by codec, raw:0x55, dag_pb:0x70, sha2_256:0x12</span><span>
</span><span style="color:#8959a8;">let</span><span> cid </span><span style="color:#3e999f;">= </span><span>Cid::new_v1(</span><span style="color:#f07219;">0x55</span><span>, Code::Sha2_256.</span><span style="color:#4271ae;">digest</span><span>(</span><span style="color:#8959a8;">b</span><span style="color:#839c00;">&quot;beep boop&quot;</span><span>));</span><span>
</span><span style="color:#8959a8;">let</span><span> data </span><span style="color:#3e999f;">=</span><span> cid.</span><span style="color:#4271ae;">to_bytes</span><span>();</span><span>
</span><span>assert_eq!(cid, Cid::try_from(data).</span><span style="color:#4271ae;">unwrap</span><span>());</span><span>
</span><span>assert_eq!(</span><span>
</span><span>    cid.</span><span style="color:#4271ae;">to_string</span><span>(),</span><span>
</span><span>    </span><span style="color:#839c00;">&quot;bafkreieq5jui4j25lacwomsqgjeswwl3y5zcdrresptwgmfylxo2depppq&quot;</span><span>
</span><span>);</span><span>
</span><span>
</span><span style="color:#8e908c;">// create 2 multiaddr</span><span>
</span><span style="color:#8959a8;">let</span><span> addr1 </span><span style="color:#3e999f;">= </span><span style="color:#839c00;">&quot;/ip4/127.0.0.1/tcp/1234&quot;</span><span>.parse::&lt;Multiaddr&gt;().</span><span style="color:#4271ae;">unwrap</span><span>();</span><span>
</span><span style="color:#8959a8;">let</span><span> addr2 </span><span style="color:#3e999f;">= </span><span>multiaddr!(Ip4([</span><span style="color:#f07219;">127</span><span>, </span><span style="color:#f07219;">0</span><span>, </span><span style="color:#f07219;">0</span><span>, </span><span style="color:#f07219;">1</span><span>]), Udp(</span><span style="color:#f07219;">10500</span><span style="color:#8959a8;">u16</span><span>), Quic);</span><span>
</span><span>assert_eq!(addr1.</span><span style="color:#4271ae;">to_string</span><span>(), </span><span style="color:#839c00;">&quot;/ip4/127.0.0.1/tcp/1234&quot;</span><span>);</span><span>
</span><span>assert_eq!(addr2.</span><span style="color:#4271ae;">to_string</span><span>(), </span><span style="color:#839c00;">&quot;/ip4/127.0.0.1/udp/10500/quic&quot;</span><span>);</span><span>
</span></code></pre>
<p>还记得初学url定义时，对&quot;:// : ? =&quot;符号的盲茫，比操作系统里的路径地址(c:\Windows\System32\Drivers\etc\hosts)多的这些有啥用，不都是要定位资源吗？有了分布式资源的描述和查询的经验后，现在都习以为常了。</p>
<p>这还不够，去中心化下要加入更多描述信息，有一种要把http协议head里的内容搬进来的感觉。还是因为没有了中心后，cid得独立描述自己了，回到哲学就是&quot;自由的选择要承担什么样的责任?&quot;
以前要与中心服务器协商的编码、通讯格式等信息，要CID独自承担了。</p>
<p>最后还要以对人类不友好，对机器友好的方式hash表现出来。</p>
<p>具体细节见 <a href="https://github.com/multiformats/cid">cid</a>, <a href="https://github.com/multiformats/multiformats">multiformats</a></p>
<h2 id="xun-zhi-lu-you-dnsji-yu-quan-wei-he-dhtji-yu-ge-ren">寻址路由 DNS基于权威和DHT基于个人</h2>
<p><img src="../images/ipfs/dns-request.png" alt="DNS" /></p>
<h3 id="dnsde-lu-you-bao-gua">DNS的路由包括</h3>
<ul>
<li>找自己的缓存hosts</li>
<li>找DNS的缓存</li>
<li>找Root DNS</li>
<li>找Top layer DNS</li>
<li>找权威的DNS</li>
</ul>
<p>同法院申诉流程(方便记忆)</p>
<p>具体细节参见<a href="https://github.com/EmilHernvall/dnsguide/blob/master/chapter1.md">自己实现一个DNS</a> rust版</p>
<p>DNS还有一种HttpDNS的实现，为了及时更新路由表</p>
<p>DNS中心化后就有了被污染、被钓鱼和缓存中毒的安全问题</p>
<h3 id="dht-distributed-hash-table-de-lu-you">DHT(Distributed Hash Table)的路由</h3>
<p><img src="../images/ipfs/dht.png" alt="DNS" /></p>
<ul>
<li>结构：DHT的路由表是前缀树组成，基于位置的分组</li>
<li>行为：4种消息来定位和加入网络，PING、STORE、FIND_NODE和FIND_VALUE</li>
<li>启动：本地DHT启动时会建立路由表&lt;peerid,multiaddr&gt;，按距离构造成树结构</li>
<li>更新：此后DHT会通过熟人peers找到更近的peeers更新路由，</li>
<li>提供发现：同时将自己也作为服务公开出去，方便别人能找到，使用MDNS实现</li>
<li>路由：并行从近到远找，基于树的路由,节点k个桶（带有该前缀的节点列表）</li>
<li>内容发现：联系与CID最近的对等点。如果有对象就发送回，如果没有就响应提供者记录。
<ul>
<li>对等点发现：对等点可能不知道提供者记录中对等点的多地址，因此它需要执行一个新的DHT查询来查找对等点的网络地址。</li>
<li>路由表每10分钟刷新一次。这通常决定了是否需要一次新的步行来获得对等人的联系信息。</li>
<li>对等点路由：使用提供者的多地址与它联系</li>
</ul>
</li>
</ul>
<p>参考<a href="http://bittorrent.org/beps/bep_0005.html">协议细节</a></p>
<p>DHT也有另一种实现，Gossip路由，基于热点聚合，路由更快但就不稳定。libp2p可以动态选择这些协议算法。</p>
<p>DHT也有DNS的安全问题，只是多个中心peers后，攻击的成本变大了。</p>
<p>与DNS相比，IPFS不只是找到IP/peerID，还要增加找ContentID和同步Content，这些不属于DHT，后面会提到。</p>
<h4 id="ipfsyu-web2-0jian-de-wang-guan">IPFS与Web2.0间的网关</h4>
<ul>
<li>_dnslink用来在web2.0下访问web3.0</li>
</ul>
<pre data-lang="sh" style="background-color:#f9f9f9;color:#111111;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#c82728;">❯</span><span style="color:#4271ae;"> dig +noall +answer TXT </span><span style="color:#f07219;">\_</span><span style="color:#4271ae;">dnslink.docs.ipfs.tech</span><span>
</span><span style="color:#c82728;">_dnslink.docs.ipfs.tech.</span><span style="color:#4271ae;"> 0      IN      CNAME   _dnslink.ipfs-docs.on.fleek.co.</span><span>
</span><span style="color:#c82728;">_dnslink.ipfs-docs.on.fleek.co.</span><span style="color:#4271ae;"> 0 IN    TXT     </span><span style="color:#839c00;">&quot;dnslink=/ipfs/QmTcCaXT7drCnfJhQmt7HAvT9PwT1XMsXVcHL7nyRqgvbc&quot;</span><span>
</span></code></pre>
<ul>
<li>IPNS subdomain</li>
</ul>
<pre data-lang="sh" style="background-color:#f9f9f9;color:#111111;" class="language-sh "><code class="language-sh" data-lang="sh"><span style="color:#3e999f;">&gt;</span><span> echo </span><span style="color:#839c00;">&quot;Hello again IPFS&quot; </span><span style="color:#3e999f;">&gt;</span><span style="color:#4271ae;"> hello.txt</span><span>
</span><span style="color:#3e999f;">&gt;</span><span> ipfs </span><span style="color:#c82728;">add</span><span style="color:#4271ae;"> hello.txt</span><span>
</span><span>
</span><span style="color:#3e999f;">&gt;</span><span> added </span><span style="color:#c82728;">QmaVfeg2GM17RLjBs9C4fhpku6uDgrEGUYCTC183VrZaVW</span><span style="color:#4271ae;"> hello.txt</span><span>
</span><span style="color:#3e999f;">&gt; </span><span style="color:#f07219;">17 </span><span style="color:#c82728;">B</span><span style="color:#4271ae;"> / 17 B </span><span style="color:#8959a8;">[</span><span style="color:#4271ae;">=====================================================</span><span style="color:#8959a8;">]</span><span style="color:#4271ae;"> 100.00%</span><span>
</span><span>
</span><span style="color:#3e999f;">&gt;</span><span> ipfs </span><span style="color:#c82728;">name</span><span style="color:#4271ae;"> publish QmaVfeg2GM17RLjBs9C4fhpku6uDgrEGUYCTC183VrZaVW</span><span>
</span><span>
</span><span style="color:#3e999f;">&gt;</span><span> Published </span><span style="color:#c82728;">to</span><span style="color:#4271ae;"> k51qzi5uqu5dkkciu33khkzbcmxtyhn376i1e83tya8kuy7z9euedzyr5nhoew: /ipfs/QmaVfeg2GM17RLjBs9C4fhpku6uDgrEGUYCTC183VrZaVW</span><span>
</span><span>
</span><span style="color:#3e999f;">&gt;</span><span> curl </span><span style="color:#c82728;">https://gateway.ipfs.io/ipns/k51qzi5uqu5dkkciu33khkzbcmxtyhn376i1e83tya8kuy7z9euedzyr5nhoew</span><span>
</span><span style="color:#3e999f;">&gt;</span><span> Hello </span><span style="color:#c82728;">again</span><span style="color:#4271ae;"> IPFS</span><span>
</span></code></pre>
<p><img src="../images/ipfs/ipns.png" alt="ipns" /></p>
<h3 id="nei-rong-lu-you-liu-cheng">内容路由流程</h3>
<p>IPFS特有的基于内容的路由</p>
<ul>
<li>内容不会被复制到其他peer，这些内容保存在用户的设备上</li>
<li>保存方式：CID作为指针指向其他peer的内容</li>
<li>保存地点：这个指针添加到20个peer保存</li>
<li>保存时间：24小时后过期失效</li>
<li>保存延续：12小时后由提供者重新发布，确保近20个对等者接收到内容，成为临时提供者</li>
</ul>
<p>基于IPLD原理</p>
<ul>
<li>multihash：指向文件的Merkle-DAG</li>
<li>文件分块：文件被分割成块，每个Chunk可独立寻址独立hash。去重，也可减小体积，分段传输</li>
<li>文件连接：每个块都表示为一个节点连接到Merkle DAG，块的哈希是节点的地址，地址都嵌在父节点中，作为链接。merkle-link</li>
<li>文件结构生成：IPLD Graph基于Merkle-DAG构建结构的标准和格式，从根开始并拆分为目录和文件。</li>
<li>抗内容重复：文件被分割成块，每个Chunk可独立寻址独立hash。去重，也可减小体积，分段传输</li>
</ul>
<h2 id="jian-li-lian-jie-tcphe-p2p">建立连接 TCP和p2p</h2>
<p>相同点：</p>
<ul>
<li>通讯：基于应答确认方式</li>
<li>安全：基于附加加密通道，TLS等</li>
<li>复用：可以复用连接，用完后不关闭，其他CID会话继续使用</li>
</ul>
<p>p2p不同点：</p>
<ul>
<li>组合获取，同时从多个peers服务中获取不同的cid资源组合在一起</li>
<li>NAT穿越，多个内网设备独立与外网设备连接</li>
<li>Pubsub，peer间双工通信</li>
</ul>
<p>libp2p作为独立成熟库，以及为多个应用服务了，功能繁多，有多种语言绑定，先不用细究</p>
<ul>
<li>Transport</li>
<li>NAT Traversal</li>
<li>Secure Communication</li>
<li>Circuit Relay</li>
<li>Protocols</li>
<li>Peer Identity</li>
<li>Content Routing</li>
<li>Peer Routing</li>
<li>Addressing</li>
<li>Security Considerations</li>
<li>Publish/Subscribe</li>
<li>Stream Multiplexing</li>
</ul>
<h2 id="fa-song-bitswapqing-qiu">发送bitswap请求</h2>
<p><img src="../images/ipfs/bitswap.png" alt="bitswap" /></p>
<p>协议</p>
<ul>
<li>Requests: WANT-HAVE / WANT-BLOCK / CANCEL</li>
<li>Responses: HAVE / BLOCK / DONT_HAVE</li>
</ul>
<p>基于内容的交换，是IPFS特有。
目的是在多个peer间同步内容资源，依赖的还是IPLD结构化</p>
<p>为了找到有文件的节点，运行 Bitswap 协议的节点首先向它连接的所有节点发送一个名为 want-have 的请求。这个需要的请求包含文件根块的 CID（根块位于组成文件的块的 DAG 的顶部）。具有根块的对等方发送有响应并被添加到会话中。没有阻止的对等方发送没有响应。 Bitswap 构建了一个DAG图，显示哪些节点拥有和不拥有每个区块。</p>
<p><img src="../images/ipfs/ipfs-bitswap.png" alt="ipfs-bitswap" /></p>
<p>基于内容的发现</p>
<ul>
<li>bitswap问数据列表中的所有“邻居”：找积极响应者</li>
<li>迭代DHT找到更接近目标。提供者记录包括提供者的PeerID和MultiAddr</li>
<li>如果提供者记录指向其他提供者的多addrs，请启动一个位交换会话 </li>
<li>DHT再次映射：PeerID-&gt;多Addr。重复：1</li>
<li>缓存内容，发布提供程序记录，在被要求时提供内容</li>
</ul>
<h3 id="graphsyncfang-shi-de-jiao-huan-dui-bi">Graphsync方式的交换对比</h3>
<table><thead><tr><th>功能</th><th>Bitswap</th><th>Graphsync</th></tr></thead><tbody>
<tr><td>Protocol type</td><td>Message-oriented</td><td>Request-Response</td></tr>
<tr><td>Content exchange</td><td>Block by block</td><td>Stream</td></tr>
<tr><td>Request patterns</td><td>CID Path</td><td>IPLD Selector</td></tr>
<tr><td>Multi-path download</td><td>Yes</td><td>No, 1:1 exchange</td></tr>
<tr><td>Use cases</td><td>Block exchange,Accelerate content routing</td><td>Blockchain sync,Large dataset sync</td></tr>
</tbody></table>
<p>扩展功能</p>
<ul>
<li>压缩</li>
<li>WANT等消息检查</li>
<li>多跳内容发现</li>
</ul>
<h2 id="ipldnei-rong-zu-he">IPLD内容组合</h2>
<p><img src="../images/ipfs/ipld.png" alt="IPLD" /></p>
<p>原理借鉴git</p>
<p>动手实验下，一个文件的<a href="https://dag.ipfs.io/">IPLD DAG化</a></p>

  </div>

  <hr class="footer-rule" />

  

  <div class="related-container">

    
      <div class="link">
        Previous <br />
        <a href="https:&#x2F;&#x2F;jimluo.github.io&#x2F;audit-upgrade&#x2F;">CWPP中Audit的升级换代</a>
      </div>
    

    

  </div>


    </main>
    <footer class="footer-page">
    
      
        <p>© 2022, Jim Luo | simple-dev-blog theme on Zola</p>

      
    
    </footer>
  </body>
</html>
